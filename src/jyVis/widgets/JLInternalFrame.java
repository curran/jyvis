/******************************************************************************
 * Copyright (C) 2007  Institute for Visualization and Perception Research,
 *                     University of Massachusetts Lowell
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *******************************************************************************/
package jyVis.widgets;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.beans.PropertyVetoException;

import javax.swing.JInternalFrame;
import javax.swing.Timer;
import javax.swing.WindowConstants;
import javax.swing.event.InternalFrameEvent;
import javax.swing.event.InternalFrameListener;

import jyVis.GlobalObjects;
import scripting.ScriptBottleneck;

/**
 * A session scripting enabled JInternalFrame
 * 
 * @author Curran Kelleher
 * 
 */
@SuppressWarnings("serial")
public class JLInternalFrame extends JInternalFrame implements
		JLWidget<JLInternalFrame.JLInternalFrameState>, ComponentListener,
		ActionListener, InternalFrameListener {
	/**
	 * The index of this InternalFrame in GlobalObjects. (a reference to this
	 * InternalFrame is added to GlobalObjects in the constructor). This index
	 * is necessary to generate the short scripts which are executed to log, and
	 * later replay, the change to the state of the InternalFrame.
	 */
	int thisInternalFramesIndex;

	/**
	 * The "internal" state, in the sense that it is the "model" for the UI.
	 * This is the value that is changed by the short scripts generated from
	 * changes in InternalFrame state. It is constantly checked for consistency
	 * with the "externalState"; when there is a difference (for example, when
	 * an outside script changes the value), the external state ("externalState"
	 * as well as the actual state of the InternalFrame) is updated to match the
	 * "internalState".
	 */
	JLInternalFrameState internalState, externalState;

	/**
	 * A flag indicating whether or not to respond to external changes. If
	 * false, UI events (such as resizing or moving), will be executed as
	 * scripts. If true, UI events will be ignored. This is to avoid
	 * unnecessarily executing scripts.
	 */
	boolean ignoreEvents = false;

	Timer timer;

	/**
	 * Construct a new JLInternalFrame with no title text.
	 * 
	 */
	public JLInternalFrame() {
		this(null);
	}

	/**
	 * Construct a new JLInternalFrame with the specified title text.
	 * 
	 * @param title
	 *            the title of the InternalFrame.
	 */
	public JLInternalFrame(String title) {
		this(title, true, true, true, true);
	}

	public JLInternalFrame(String title, boolean resizable, boolean closeable,
			boolean maximizable, boolean iconifiable) {

		super(title, resizable, closeable, maximizable, iconifiable);
		// initialize the internal state
		internalState = externalState = new JLInternalFrameState(this);
		// set up this InternalFrame with the JLWidget periodic check and update
		// InternalFramework (periodically, the internal and external states are
		// checked for consistency. when they don't match, the external state
		// (the actual state of the UI) is changed to reflect the internal
		// state).
		JLPeriodicUpdateThread.setupJLWidget(this);

		// add this InternalFrame to GlobalObjects and store it's index in that
		// list (the script generated by an action must somehow get access to
		// this InternalFrame object instance in order to change it, this index
		// is used by the script to retrieve this instance from GlobalObjects)
		this.thisInternalFramesIndex = GlobalObjects.add(this);
		timer = new Timer(1000, this);
		timer.setRepeats(false);
		// add the listener for resize and move events
		addComponentListener(this);
		// add the listener for minimization ("iconification")
		addInternalFrameListener(this);
		// set the InternalFrame to hide on close
		setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
	}

	/**
	 * Part of the JLWidget InternalFramework. Gets the external value, the
	 * "view," the value currently being displayed by the UI.
	 */
	public JLInternalFrameState getExternalState() {
		synchronized (this) {
			return externalState;
		}
	}

	/**
	 * Part of the JLWidget InternalFramework. Sets the external value, the
	 * "view," the value currently being displayed by the UI. This actually
	 * updates the UI, which causes events to be fired, but the events in this
	 * case should be ignored. The implementation of this method takes care of
	 * that by setting a flag to ignore UI events, changing the UI, then turning
	 * that flag off. If this is not done, there are redundant double executions
	 * of scripts.
	 * 
	 * @param newValue
	 *            the new value which the UI should have
	 */
	public void setExternalState(JLInternalFrameState newValue) {
		if (!newValue.equals(externalState) && !timer.isRunning()) {
			ignoreEvents = true;
			newValue.applyToInternalFrame(this);
			ignoreEvents = false;
		}
	}

	/**
	 * Part of the JLWidget InternalFramework. Gets the internal value, the
	 * "model," the value currently held internally.
	 */
	public JLInternalFrameState getInternalState() {
		synchronized (this) {
			return internalState;
		}
	}

	/**
	 * A method which sets the value of the internal state for this
	 * InternalFrame.
	 * 
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param icon
	 *            whether or not the frame is iconified (minimized)
	 * @param maximum
	 *            whether or not the frame is maximized
	 * @param visible
	 */
	public void setInternalState(int x, int y, int width, int height,
			boolean icon, boolean maximum, boolean visible) {
		internalState = new JLInternalFrameState(x, y, width, height, icon,
				maximum, visible);
		setExternalState(internalState);
	}

	/**
	 * A method which sets the value of the internal state for this
	 * InternalFrame.
	 * 
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param icon
	 *            whether or not the frame is iconified (minimized)
	 * @param maximum
	 *            whether or not the frame is maximized
	 * @param visible
	 */
	public void setInternalState(Integer x, Integer y, Integer width,
			Integer height, Boolean icon, Boolean maximum, Boolean visible) {
		setInternalState(x.intValue(), y.intValue(), width.intValue(), height
				.intValue(), icon.booleanValue(), maximum.booleanValue(),
				visible.booleanValue());
	}

	public void componentHidden(ComponentEvent arg0) {
		if (!ignoreEvents)
			updateState();
	}

	public void componentMoved(ComponentEvent arg0) {
		if (!ignoreEvents)
			restartTimer();
	}

	public void componentResized(ComponentEvent arg0) {
		if (!ignoreEvents)
			restartTimer();
	}

	public void componentShown(ComponentEvent arg0) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameActivated(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameClosed(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameClosing(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameDeactivated(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameDeiconified(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameIconified(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	public void internalFrameOpened(InternalFrameEvent e) {
		if (!ignoreEvents)
			updateState();
	}

	/**
	 * Sets the internal value to the current externalValue via a script.
	 */
	public void restartTimer() {
		timer.restart();
	}

	/**
	 * Sets the internal value to the current externalValue via a script.
	 */
	public void updateState() {
		// this synchronized block is key, because it guarantees that the
		// external and internal states will be set at the same time, and since
		// getInternalState() and getExternalState() are also synchronized on
		// the same object, the external and internal states will never be
		// different as a result of user interaction (which was a major
		// bug-causing issue) at least in the view that the update thread has
		// (because it goes through getInternalState() and getExternalState())
		synchronized (this) {
			externalState = new JLInternalFrameState(this);
			if (!internalState.equals(externalState)) {
				ScriptBottleneck.importIfNotDefined("python",
						GlobalObjects.class);
				ScriptBottleneck.exec("python", "GlobalObjects.get("
						+ thisInternalFramesIndex + ").setInternalState("
						+ externalState + ")");
			}
		}
	}

	/**
	 * Called when the timer runs out
	 */
	public void actionPerformed(ActionEvent arg0) {
		updateState();
	}

	/**
	 * This method kills the frames timer if it is on
	 */
	public void kill() {
		// remove listeners
		removeComponentListener(this);
		removeInternalFrameListener(this);
		// kill timer
		if (timer.isRunning())
			timer.stop();
	}

	/**
	 * A class which immutably stores the state of a JLInternalFrame. This class
	 * is only used inside JLInternalFrame.
	 * 
	 * @author Curran Kelleher
	 * 
	 */
	public class JLInternalFrameState {
		public final int x, y, width, height;

		public final boolean visible, icon, maximum;

		/**
		 * Creates a JLInternalFrameState from the current state of the
		 * specified InternalFrame
		 * 
		 * @param InternalFrame
		 */
		public JLInternalFrameState(JInternalFrame InternalFrame) {
			x = InternalFrame.getX();
			y = InternalFrame.getY();
			width = InternalFrame.getWidth();
			height = InternalFrame.getHeight();
			icon = InternalFrame.isIcon();
			maximum = InternalFrame.isMaximum();
			visible = InternalFrame.isVisible();
		}

		/**
		 * Create a JLInternalFrameState with the specified parameters.
		 * 
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 * @param icon
		 *            whether or not the frame is iconified (minimized)
		 * @param maximum
		 *            whether or not the frame is maximized
		 * @param visible
		 */
		public JLInternalFrameState(int x, int y, int width, int height,
				boolean icon, boolean maximum, boolean visible) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.icon = icon;
			this.maximum = maximum;
			this.visible = visible;
		}

		/**
		 * Sets the state of the specified InternalFrame to match this state.
		 * 
		 * @param internalFrame
		 */
		public void applyToInternalFrame(JInternalFrame internalFrame) {
			JLInternalFrameState s = new JLInternalFrameState(internalFrame);
			// System.out.println("outer");
			if (s.visible != visible)
				internalFrame.setVisible(visible);
			if (s.x != x || s.y != y || s.width != width || s.height != height)
				internalFrame.setBounds(x, y, width, height);
			try {
				if (s.icon != icon)
					internalFrame.setIcon(icon);
				if (s.maximum != maximum)
					internalFrame.setMaximum(maximum);
				if (!internalFrame.isSelected()) {
					// System.out.println("isVisible = " +
					// internalFrame.isVisible());
					// System.out.println("inner");
					internalFrame.setSelected(true);
				}
			} catch (PropertyVetoException e) {
				e.printStackTrace();
			}

		}

		/**
		 * Returns comma delimited values, in the same order as the arguments to
		 * the method JLInternalFrame.setInternalState
		 */
		public String toString() {
			return x + "," + y + "," + width + "," + height + ","
					+ (icon ? 1 : 0) + "," + (maximum ? 1 : 0) + ","
					+ (visible ? 1 : 0);
		}

		/**
		 * Ttests for equality of two JLInternalFrameStates
		 */
		public boolean equals(Object o) {
			if (o instanceof JLInternalFrameState) {
				JLInternalFrameState s = (JLInternalFrameState) o;
				if (s.x == x)
					if (s.y == y)
						if (s.width == width)
							if (s.height == height)
								if (s.icon == icon)
									if (s.maximum == maximum)
										if (s.visible == visible)
											return true;
			}
			return false;
		}

	}
}
/*
 * CVS Log
 * 
 * $Log: JLInternalFrame.java,v $
 * Revision 1.1  2007/08/15 17:59:14  curran
 * Initial commit to SourceForge
 * Revision 1.2 2007/07/30 23:43:04 ckellehe
 * Cleaned up Javadoc Revision 1.1 2007/07/26 00:31:00 ckellehe Initial Creation
 * Revision 1.10 2007/06/28 15:42:57 ckellehe Sort of fixed internal frame focus
 * on replay (internal frame changes make it get focus, except for the first
 * time it is show.)
 * 
 * Revision 1.9 2007/06/28 15:18:12 ckellehe Fixed layout bug in internal frames
 * Revision 1.8 2007/06/27 20:56:54 ckellehe Got session replay working for
 * radViz mouse events
 * 
 * Revision 1.7 2007/06/27 15:46:34 ckellehe Got sessions working
 * 
 * Revision 1.6 2007/06/19 18:50:49 ckellehe Encapsulated Function objects from
 * scripts such that internal state script generation is independent of the
 * language used to create the function Revision 1.5 2007/06/15 18:01:27
 * ckellehe Added an additional String parameter to ScriptBottleneck.exec,
 * specifying what language interpreter to use for executing the script
 * 
 * Revision 1.4 2007/06/15 17:53:18 ckellehe removed old importIfNotDefined
 * method from ScriptBottleneck
 * 
 * Revision 1.3 2007/06/14 15:50:56 ckellehe Renamed JythonBottleneck to
 * ScriptBottleneck
 * 
 * Revision 1.2 2007/06/08 15:01:44 ckellehe Initial Creation
 * 
 */
